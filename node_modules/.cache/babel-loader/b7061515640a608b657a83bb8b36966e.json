{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _generated = require(\"../builders/generated\");\n\nvar _default = valueToNode;\nexports.default = _default;\nconst objectToString = Function.call.bind(Object.prototype.toString);\n\nfunction isRegExp(value) {\n  return objectToString(value) === \"[object RegExp]\";\n}\n\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null || Object.prototype.toString.call(value) !== \"[object Object]\") {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return (0, _generated.identifier)(\"undefined\");\n  }\n\n  if (value === true || value === false) {\n    return (0, _generated.booleanLiteral)(value);\n  }\n\n  if (value === null) {\n    return (0, _generated.nullLiteral)();\n  }\n\n  if (typeof value === \"string\") {\n    return (0, _generated.stringLiteral)(value);\n  }\n\n  if (typeof value === \"number\") {\n    let result;\n\n    if (Number.isFinite(value)) {\n      result = (0, _generated.numericLiteral)(Math.abs(value));\n    } else {\n      let numerator;\n\n      if (Number.isNaN(value)) {\n        numerator = (0, _generated.numericLiteral)(0);\n      } else {\n        numerator = (0, _generated.numericLiteral)(1);\n      }\n\n      result = (0, _generated.binaryExpression)(\"/\", numerator, (0, _generated.numericLiteral)(0));\n    }\n\n    if (value < 0 || Object.is(value, -0)) {\n      result = (0, _generated.unaryExpression)(\"-\", result);\n    }\n\n    return result;\n  }\n\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return (0, _generated.regExpLiteral)(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return (0, _generated.arrayExpression)(value.map(valueToNode));\n  }\n\n  if (isPlainObject(value)) {\n    const props = [];\n\n    for (const key of Object.keys(value)) {\n      let nodeKey;\n\n      if ((0, _isValidIdentifier.default)(key)) {\n        nodeKey = (0, _generated.identifier)(key);\n      } else {\n        nodeKey = (0, _generated.stringLiteral)(key);\n      }\n\n      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));\n    }\n\n    return (0, _generated.objectExpression)(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}","map":{"version":3,"mappings":";;;;;;;;;AAAA;;AACA;;eAeeA;;AAkBf,MAAMC,cAA0C,GAAGC,QAAQ,CAACC,IAATD,CAAcE,IAAdF,CACjDG,MAAM,CAACC,SAAPD,CAAiBE,QADgCL,CAAnD;;AAIA,SAASM,QAAT,CAAkBC,KAAlB,EAAmD;EACjD,OAAOR,cAAc,CAACQ,KAAD,CAAdR,KAA0B,iBAAjC;AACD;;AAED,SAASS,aAAT,CAAuBD,KAAvB,EAAwD;EACtD,IACE,OAAOA,KAAP,KAAiB,QAAjB,IACAA,KAAK,KAAK,IADV,IAEAJ,MAAM,CAACC,SAAPD,CAAiBE,QAAjBF,CAA0BF,IAA1BE,CAA+BI,KAA/BJ,MAA0C,iBAH5C,EAIE;IACA,OAAO,KAAP;EACD;;EACD,MAAMM,KAAK,GAAGN,MAAM,CAACO,cAAPP,CAAsBI,KAAtBJ,CAAd;EAIA,OAAOM,KAAK,KAAK,IAAVA,IAAkBN,MAAM,CAACO,cAAPP,CAAsBM,KAAtBN,MAAiC,IAA1D;AACD;;AAED,SAASL,WAAT,CAAqBS,KAArB,EAAmD;EAEjD,IAAIA,KAAK,KAAKI,SAAd,EAAyB;IACvB,OAAO,2BAAW,WAAX,CAAP;EACD;;EAGD,IAAIJ,KAAK,KAAK,IAAVA,IAAkBA,KAAK,KAAK,KAAhC,EAAuC;IACrC,OAAO,+BAAeA,KAAf,CAAP;EACD;;EAGD,IAAIA,KAAK,KAAK,IAAd,EAAoB;IAClB,OAAO,6BAAP;EACD;;EAGD,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;IAC7B,OAAO,8BAAcA,KAAd,CAAP;EACD;;EAGD,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;IAC7B,IAAIK,MAAJ;;IACA,IAAIC,MAAM,CAACC,QAAPD,CAAgBN,KAAhBM,CAAJ,EAA4B;MAC1BD,MAAM,GAAG,+BAAeG,IAAI,CAACC,GAALD,CAASR,KAATQ,CAAf,CAATH;IADF,OAEO;MACL,IAAIK,SAAJ;;MACA,IAAIJ,MAAM,CAACK,KAAPL,CAAaN,KAAbM,CAAJ,EAAyB;QAEvBI,SAAS,GAAG,+BAAe,CAAf,CAAZA;MAFF,OAGO;QAELA,SAAS,GAAG,+BAAe,CAAf,CAAZA;MACD;;MAEDL,MAAM,GAAG,iCAAiB,GAAjB,EAAsBK,SAAtB,EAAiC,+BAAe,CAAf,CAAjC,CAATL;IACD;;IAED,IAAIL,KAAK,GAAG,CAARA,IAAaJ,MAAM,CAACgB,EAAPhB,CAAUI,KAAVJ,EAAiB,CAAC,CAAlBA,CAAjB,EAAuC;MACrCS,MAAM,GAAG,gCAAgB,GAAhB,EAAqBA,MAArB,CAATA;IACD;;IAED,OAAOA,MAAP;EACD;;EAGD,IAAIN,QAAQ,CAACC,KAAD,CAAZ,EAAqB;IACnB,MAAMa,OAAO,GAAGb,KAAK,CAACc,MAAtB;IACA,MAAMC,KAAK,GAAGf,KAAK,CAACF,QAANE,GAAiBgB,KAAjBhB,CAAuB,cAAvBA,EAAuC,CAAvCA,CAAd;IACA,OAAO,8BAAca,OAAd,EAAuBE,KAAvB,CAAP;EACD;;EAGD,IAAIE,KAAK,CAACC,OAAND,CAAcjB,KAAdiB,CAAJ,EAA0B;IACxB,OAAO,gCAAgBjB,KAAK,CAACmB,GAANnB,CAAUT,WAAVS,CAAhB,CAAP;EACD;;EAGD,IAAIC,aAAa,CAACD,KAAD,CAAjB,EAA0B;IACxB,MAAMoB,KAAK,GAAG,EAAd;;IACA,KAAK,MAAMC,GAAX,IAAkBzB,MAAM,CAAC0B,IAAP1B,CAAYI,KAAZJ,CAAlB,EAAsC;MACpC,IAAI2B,OAAJ;;MACA,IAAI,gCAAkBF,GAAlB,CAAJ,EAA4B;QAC1BE,OAAO,GAAG,2BAAWF,GAAX,CAAVE;MADF,OAEO;QACLA,OAAO,GAAG,8BAAcF,GAAd,CAAVE;MACD;;MACDH,KAAK,CAACI,IAANJ,CACE,+BACEG,OADF,EAEEhC,WAAW,CAETS,KAAK,CAACqB,GAAD,CAFI,CAFb,CADFD;IASD;;IACD,OAAO,iCAAiBA,KAAjB,CAAP;EACD;;EAED,MAAM,IAAIK,KAAJ,CAAU,+CAAV,CAAN;AACD","names":["valueToNode","objectToString","Function","call","bind","Object","prototype","toString","isRegExp","value","isPlainObject","proto","getPrototypeOf","undefined","result","Number","isFinite","Math","abs","numerator","isNaN","is","pattern","source","flags","match","Array","isArray","map","props","key","keys","nodeKey","push","Error"],"sources":["../../src/converters/valueToNode.ts"],"sourcesContent":["import isValidIdentifier from \"../validators/isValidIdentifier\";\nimport {\n  identifier,\n  booleanLiteral,\n  nullLiteral,\n  stringLiteral,\n  numericLiteral,\n  regExpLiteral,\n  arrayExpression,\n  objectProperty,\n  objectExpression,\n  unaryExpression,\n  binaryExpression,\n} from \"../builders/generated\";\nimport type * as t from \"..\";\n\nexport default valueToNode as {\n  (value: undefined): t.Identifier; // TODO: This should return \"void 0\"\n  (value: boolean): t.BooleanLiteral;\n  (value: null): t.NullLiteral;\n  (value: string): t.StringLiteral;\n  // Infinities and NaN need to use a BinaryExpression; negative values must be wrapped in UnaryExpression\n  (value: number): t.NumericLiteral | t.BinaryExpression | t.UnaryExpression;\n  (value: RegExp): t.RegExpLiteral;\n  (value: ReadonlyArray<unknown>): t.ArrayExpression;\n\n  // this throws with objects that are not plain objects,\n  // or if there are non-valueToNode-able values\n  (value: object): t.ObjectExpression;\n\n  (value: unknown): t.Expression;\n};\n\n// @ts-expect-error: Object.prototype.toString must return a string\nconst objectToString: (value: unknown) => string = Function.call.bind(\n  Object.prototype.toString,\n);\n\nfunction isRegExp(value: unknown): value is RegExp {\n  return objectToString(value) === \"[object RegExp]\";\n}\n\nfunction isPlainObject(value: unknown): value is object {\n  if (\n    typeof value !== \"object\" ||\n    value === null ||\n    Object.prototype.toString.call(value) !== \"[object Object]\"\n  ) {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  // Object.prototype's __proto__ is null. Every other class's __proto__.__proto__ is\n  // not null by default. We cannot check if proto === Object.prototype because it\n  // could come from another realm.\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\n\nfunction valueToNode(value: unknown): t.Expression {\n  // undefined\n  if (value === undefined) {\n    return identifier(\"undefined\");\n  }\n\n  // boolean\n  if (value === true || value === false) {\n    return booleanLiteral(value);\n  }\n\n  // null\n  if (value === null) {\n    return nullLiteral();\n  }\n\n  // strings\n  if (typeof value === \"string\") {\n    return stringLiteral(value);\n  }\n\n  // numbers\n  if (typeof value === \"number\") {\n    let result;\n    if (Number.isFinite(value)) {\n      result = numericLiteral(Math.abs(value));\n    } else {\n      let numerator;\n      if (Number.isNaN(value)) {\n        // NaN\n        numerator = numericLiteral(0);\n      } else {\n        // Infinity / -Infinity\n        numerator = numericLiteral(1);\n      }\n\n      result = binaryExpression(\"/\", numerator, numericLiteral(0));\n    }\n\n    if (value < 0 || Object.is(value, -0)) {\n      result = unaryExpression(\"-\", result);\n    }\n\n    return result;\n  }\n\n  // regexes\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return regExpLiteral(pattern, flags);\n  }\n\n  // array\n  if (Array.isArray(value)) {\n    return arrayExpression(value.map(valueToNode));\n  }\n\n  // object\n  if (isPlainObject(value)) {\n    const props = [];\n    for (const key of Object.keys(value)) {\n      let nodeKey;\n      if (isValidIdentifier(key)) {\n        nodeKey = identifier(key);\n      } else {\n        nodeKey = stringLiteral(key);\n      }\n      props.push(\n        objectProperty(\n          nodeKey,\n          valueToNode(\n            // @ts-expect-error key must present in value\n            value[key],\n          ),\n        ),\n      );\n    }\n    return objectExpression(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}\n"]},"metadata":{},"sourceType":"script"}