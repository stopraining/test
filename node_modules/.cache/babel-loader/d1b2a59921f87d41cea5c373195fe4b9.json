{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\n\nvar _generated = require(\"../../validators/generated\");\n\nfunction getQualifiedName(node) {\n  return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\nfunction removeTypeDuplicates(nodes) {\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isFlowBaseAnnotation)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if ((0, _generated.isUnionTypeAnnotation)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes = nodes.concat(node.types);\n        typeGroups.add(node.types);\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isGenericTypeAnnotation)(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}","map":{"version":3,"mappings":";;;;;;;AAAA;;AASA,SAASA,gBAAT,CAA0BC,IAA1B,EAAuE;EACrE,OAAO,6BAAaA,IAAb,IACHA,IAAI,CAACC,IADF,GAEF,GAAED,IAAI,CAACE,EAALF,CAAQC,IAAK,IAAGF,gBAAgB,CAACC,IAAI,CAACG,aAAN,CAAqB,EAF5D;AAGD;;AAKc,SAASC,oBAAT,CAEbC,KAFa,EAGC;EACd,MAAMC,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;EACA,MAAMC,KAAK,GAAG,IAAID,GAAJ,EAAd;EAGA,MAAME,UAAU,GAAG,IAAIC,GAAJ,EAAnB;EAEA,MAAMC,KAAmB,GAAG,EAA5B;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAAK,CAACQ,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;IACrC,MAAMZ,IAAI,GAAGK,KAAK,CAACO,CAAD,CAAlB;IACA,IAAI,CAACZ,IAAL,EAAW;;IAGX,IAAIW,KAAK,CAACG,OAANH,CAAcX,IAAdW,KAAuB,CAA3B,EAA8B;MAC5B;IACD;;IAGD,IAAI,oCAAoBX,IAApB,CAAJ,EAA+B;MAC7B,OAAO,CAACA,IAAD,CAAP;IACD;;IAED,IAAI,qCAAqBA,IAArB,CAAJ,EAAgC;MAC9BQ,KAAK,CAACO,GAANP,CAAUR,IAAI,CAACgB,IAAfR,EAAqBR,IAArBQ;MACA;IACD;;IAED,IAAI,sCAAsBR,IAAtB,CAAJ,EAAiC;MAC/B,IAAI,CAACS,UAAU,CAACQ,GAAXR,CAAeT,IAAI,CAACW,KAApBF,CAAL,EAAiC;QAE/BJ,KAAK,GAAGA,KAAK,CAACa,MAANb,CAAaL,IAAI,CAACW,KAAlBN,CAARA;QACAI,UAAU,CAACU,GAAXV,CAAeT,IAAI,CAACW,KAApBF;MACD;;MACD;IACD;;IAGD,IAAI,wCAAwBT,IAAxB,CAAJ,EAAmC;MACjC,MAAMC,IAAI,GAAGF,gBAAgB,CAACC,IAAI,CAACE,EAAN,CAA7B;;MAEA,IAAII,QAAQ,CAACW,GAATX,CAAaL,IAAbK,CAAJ,EAAwB;QACtB,IAAIc,QAAgB,GAAGd,QAAQ,CAACe,GAATf,CAAaL,IAAbK,CAAvB;;QACA,IAAIc,QAAQ,CAACE,cAAb,EAA6B;UAC3B,IAAItB,IAAI,CAACsB,cAAT,EAAyB;YACvBF,QAAQ,CAACE,cAATF,CAAwBG,MAAxBH,GAAiChB,oBAAoB,CACnDgB,QAAQ,CAACE,cAATF,CAAwBG,MAAxBH,CAA+BF,MAA/BE,CAAsCpB,IAAI,CAACsB,cAALtB,CAAoBuB,MAA1DH,CADmD,CAArDA;UAGD;QALH,OAMO;UACLA,QAAQ,GAAGpB,IAAI,CAACsB,cAAhBF;QACD;MAVH,OAWO;QACLd,QAAQ,CAACS,GAATT,CAAaL,IAAbK,EAAmBN,IAAnBM;MACD;;MAED;IACD;;IAEDK,KAAK,CAACa,IAANb,CAAWX,IAAXW;EACD;;EAGD,KAAK,MAAM,GAAGc,QAAH,CAAX,IAA2BjB,KAA3B,EAAkC;IAChCG,KAAK,CAACa,IAANb,CAAWc,QAAXd;EACD;;EAGD,KAAK,MAAM,GAAGe,WAAH,CAAX,IAA8BpB,QAA9B,EAAwC;IACtCK,KAAK,CAACa,IAANb,CAAWe,WAAXf;EACD;;EAED,OAAOA,KAAP;AACD","names":["getQualifiedName","node","name","id","qualification","removeTypeDuplicates","nodes","generics","Map","bases","typeGroups","Set","types","i","length","indexOf","set","type","has","concat","add","existing","get","typeParameters","params","push","baseType","genericName"],"sources":["../../../src/modifications/flow/removeTypeDuplicates.ts"],"sourcesContent":["import {\n  isAnyTypeAnnotation,\n  isGenericTypeAnnotation,\n  isUnionTypeAnnotation,\n  isFlowBaseAnnotation,\n  isIdentifier,\n} from \"../../validators/generated\";\nimport type * as t from \"../..\";\n\nfunction getQualifiedName(node: t.GenericTypeAnnotation[\"id\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  // todo(babel-8): change type to Array<...>\n  nodes: ReadonlyArray<t.FlowType | false | null | undefined>,\n): t.FlowType[] {\n  const generics = new Map<string, t.GenericTypeAnnotation>();\n  const bases = new Map<t.FlowBaseAnnotation[\"type\"], t.FlowBaseAnnotation>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.FlowType[]>();\n\n  const types: t.FlowType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    if (isFlowBaseAnnotation(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isUnionTypeAnnotation(node)) {\n      if (!typeGroups.has(node.types)) {\n        // todo(babel-8): use .push when nodes is mutable\n        nodes = nodes.concat(node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // find a matching generic type and merge and deduplicate the type parameters\n    if (isGenericTypeAnnotation(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics.has(name)) {\n        let existing: t.Flow = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(\n              existing.typeParameters.params.concat(node.typeParameters.params),\n            );\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n"]},"metadata":{},"sourceType":"script"}